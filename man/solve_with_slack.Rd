% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solve_with_slack.R
\name{solve_with_slack}
\alias{solve_with_slack}
\title{Solve an infeasible mstATA model using block-level slack variables}
\usage{
solve_with_slack(
  model_spec,
  cat_penalty,
  quant_penalty,
  solver = c("gurobi", "lpsolve", "HiGHS", "Symphony", "GLPK"),
  time_limit = 99999
)
}
\arguments{
\item{model_spec}{An object of class \code{mstATA_model}. The model may be
infeasible under its original specification.}

\item{cat_penalty}{Numeric scalar giving the penalty coefficient applied to
slack variables associated with categorical constraint blocks. Larger values
discourage violations of categorical requirements.}

\item{quant_penalty}{Numeric scalar giving the penalty coefficient applied to
slack variables associated with quantitative constraint blocks.}

\item{solver}{A character string indicating which solver to use.
One of \code{"gurobi"}, \code{"lpsolve"}, \code{"HiGHS"},
\code{"Symphony"}, or \code{"GLPK"}.}

\item{time_limit}{The maximum amount of computation time allocated to the solver.
Default is 99999 seconds.}
}
\value{
A solver result object returned by \code{solve_model()}, containing the
optimized solution, solver status, and objective value for the relaxed model.
Slack variable values indicate the magnitude of constraint violations at the
block level.
}
\description{
Attempts to recover feasibility for an infeasible \code{mstATA_model} by
relaxing selected non-core constraint blocks using slack variables with
user-specified penalties. A single continuous slack variable is introduced
for each relaxable constraint block, allowing controlled violations while
preserving the core structure of the MST design.

This function is intended as a diagnostic and fallback tool rather than a
replacement for strict feasibility checks.
}
\details{
The relaxed model is constructed as follows:

\itemize{
\item \strong{Hard constraints (never relaxed):}
\itemize{
\item Objective-related constraints.
\item Essential MST structure constraints (e.g., module- and pathway-level
item count constraints, optional requirements for routing decision points).
\item Logical constraints (e.g., enemy relationships, item-stimulus grouping relationships, item exposure control).
\item Equality constraints, identified by
\code{specification$Operator == "(exact)"} at the block level.
}

\item \strong{Soft constraints (relaxed with slack):}
\itemize{
\item Categorical constraint blocks.
\item Quantitative constraint blocks.
}
}

For each relaxable constraint block, one nonnegative continuous slack variable
is introduced and shared across all rows in that block. Slack coefficients are
assigned according to the row operator:

\itemize{
\item For \code{"<="} rows, the slack enters with coefficient \eqn{-1}.
\item For \code{">="} rows, the slack enters with coefficient \eqn{+1}.
}

Soft constraint blocks must contain only \code{"<="} or \code{">="} rows.

The objective function is augmented by adding penalty terms for each slack
variable. Categorical slack variables are penalized \strong{more heavily} than
quantitative slack variables to reflect their higher priority.
}
\section{Mathematical Formulation}{


Consider an infeasible mstATA model consisting of a set of constraint blocks
indexed by \eqn{b = 1,\dots,B}. Each block \eqn{b} corresponds to one row in
the specification table and may contain multiple linear constraint rows
indexed by \eqn{r \in \mathcal{R}_b}.

For each constraint row, let \eqn{a_r^\top x} denote the left-hand side
linear expression and \eqn{d_r} the right-hand side constant.

\strong{Soft constraint blocks and slack variables.}
For each relaxable constraint block \eqn{b} (categorical or quantitative),
a single nonnegative continuous slack variable \eqn{s_b \ge 0} is introduced
and shared across all rows in that block.

\strong{Original (hard) constraints.}
For a row \eqn{r \in \mathcal{R}_b}, the original linear constraint takes one
of the following forms:

\itemize{
\item \strong{Upper-bound constraint:}
\deqn{a_r^\top x \le d_r}

\item \strong{Lower-bound constraint:}
\deqn{a_r^\top x \ge d_r}
}

Equality constraints (\eqn{a_r^\top x = d_r}) are not relaxable and therefore
are excluded from slack construction.

\strong{Relaxed constraints with block-level slack.}
For a relaxable block \eqn{b}, each row \eqn{r \in \mathcal{R}_b} is modified
as follows:

\itemize{
\item If the original row is \eqn{a_r^\top x \le d_r}, the relaxed form is
\deqn{a_r^\top x \le d_r + s_b.}

\item If the original row is \eqn{a_r^\top x \ge d_r}, the relaxed form is
\deqn{a_r^\top x \ge d_r - s_b.}
}

Equivalently, in matrix form, the slack variable \eqn{s_b} enters each row
with coefficient \eqn{-1} for \code{"<="} constraints and \eqn{+1} for
\code{">="} constraints. A single slack variable therefore bounds the maximum
violation across all rows in the block.

\strong{Categorical vs quantitative constraints.}
The mathematical relaxation is identical for categorical and quantitative
constraint. They differ only in the penalty applied to their slack
variables in the objective function. Categorical constraints are penalized
more heavily to reflect higher priority.

\strong{Objective function with slack penalties.}
Let \eqn{\mathcal{B}_{\text{cat}}} and \eqn{\mathcal{B}_{\text{quant}}} denote
the sets of categorical and quantitative soft constraint blocks, respectively.
The relaxed optimization problem augments the original objective by adding
slack penalties:

\deqn{
\min \; f(x)
+ \sum_{b \in \mathcal{B}_{\text{cat}}} \lambda_{\text{cat}}\, s_b
+ \sum_{b \in \mathcal{B}_{\text{quant}}} \lambda_{\text{quant}}\, s_b,
}

where \eqn{f(x)} denotes the original objective function, and
\eqn{\lambda_{\text{cat}} > \lambda_{\text{quant}} > 0} are user-specified
penalty coefficients.

If the original problem is a maximization problem, the equivalent formulation
is obtained by subtracting the slack penalties from the objective:

\deqn{
\max \; f(x)
- \sum_{b \in \mathcal{B}_{\text{cat}}} \lambda_{\text{cat}}\, s_b
- \sum_{b \in \mathcal{B}_{\text{quant}}} \lambda_{\text{quant}}\, s_b.
}

The resulting solution represents a best-compromise feasible design that
minimizes violations of high-priority constraints before lower-priority ones.
}

\seealso{
\code{\link{check_singleblock_feasibility}},
\code{\link{check_comblock_feasibility}},
\code{\link{solve_model}}
}
