% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/module_score_dist.R
\name{module_score_dist}
\alias{module_score_dist}
\title{Module score distribution at one or more ability values}
\usage{
module_score_dist(icc)
}
\arguments{
\item{icc}{A named list of item-by-category probability matrices evaluated
at one or more ability values. Each element corresponds to a single
ability value \eqn{\theta} and must be a numeric matrix with rows
representing items and columns representing score categories
(\code{cat0}, \code{cat1}, \dots).

For mixed dichotomous and polytomous modules, dichotomous items must be
padded so that all matrices share the same set of category columns, with
higher-category probabilities set to zero.}
}
\value{
A numeric matrix giving conditional module score distributions at target theta values.
Rows correspond to total scores
\eqn{s = 0,\dots,\sum_i m_i}. Columns correspond to ability values
\eqn{\theta}. Each column sums to one.
}
\description{
Compute the conditional distribution of total module scores given
one or more ability values (\eqn{\theta}). by convolving item-level score category
probabilities.

This function assumes that item category probabilities have already been
computed (e.g., via \code{compute_icc()}) and are provided on a common
category scale.
}
\details{
Consider a module consisting of \eqn{I} items. Let the score for item
\eqn{i} be a discrete random variable \eqn{Y_i} taking values
\eqn{\{0,1,\dots,m_i\}}. Conditional on ability \eqn{\theta}, assume
local independence:

\deqn{
\Pr(Y_1,\dots,Y_I \mid \theta)
  = \prod_{i=1}^{I} \Pr(Y_i \mid \theta).
}

The total module score is

\deqn{
S = \sum_{i=1}^{I} Y_i,
}

with support \eqn{\{0,\dots,\sum_i m_i\}}. For a fixed ability level
\eqn{\theta}, the conditional distribution of \eqn{S} is obtained by
discrete convolution of the item-level category probability vectors:

\deqn{
\Pr(S = s \mid \theta)
  = (p_{1} * p_{2} * \cdots * p_{I})(s),
}

where \eqn{p_i = (p_{i0}(\theta),\dots,p_{im_i}(\theta))} and \eqn{*}
denotes convolution.

This function applies the above operation independently at each
ability level.
}
\examples{
## Example 1: Dichotomous model
data("mini_itempool")
icc_mat<-compute_icc(mini_itempool,list("3PL"=c("discrimination","difficulty","guessing")),
            theta = 0,model_col = "model",D = 1.7)

icc_list<-compute_icc(mini_itempool,list("3PL"=c("discrimination","difficulty","guessing")),
            theta = seq(-5,5,0.1),model_col = "model",D = 1.7)

module_score_dist(icc_mat[[1]])
module_score_dist(icc_list)

## Example 2: Polytomous model (PCM)
data("poly_itempool")
icc_mat<-compute_icc(poly_itempool,list("PCM"=c("deltaj1","deltaj2","deltaj3")),
            theta = 0,model_col = "model")
icc_list<-compute_icc(poly_itempool,list("PCM"=c("deltaj1","deltaj2","deltaj3")),
            theta = seq(-5,5,0.1),model_col = "model")
module_score_dist(icc_mat[[1]])
module_score_dist(icc_list)

## Example 3: multiple IRT models (3PL + GPCM + GRM)
data("Rmst_pool")
icc_mat<-compute_icc(Rmst_pool,item_par_cols = list("3PL"=c("a","b","c"),
                                           "GPCM" = c("alpha","delta1","delta2","delta3"),
                                            "GRM" = c("alpha","beta1","beta2")),
            theta = 0,model_col = "model")
icc_list<-compute_icc(Rmst_pool,item_par_cols = list("3PL"=c("a","b","c"),
                                           "GPCM" = c("alpha","delta1","delta2","delta3"),
                                            "GRM" = c("alpha","beta1","beta2")),
            theta = 0,model_col = "model")
module_score_dist(icc_mat[[1]])
module_score_dist(icc_list)
}
