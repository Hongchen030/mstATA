% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dvlink_item_solution.R
\name{dvlink_item_solution}
\alias{dvlink_item_solution}
\title{Defining Solution-level Item Indicator Variables and Generating Constraints for Item Exposure Control Across Multiple Panels}
\usage{
dvlink_item_solution(
  x,
  num_panels,
  global_min_use = 0,
  global_max_use = Inf,
  item_min_use = NULL,
  item_max_use = NULL
)
}
\arguments{
\item{x}{An object of class \code{"mstATA_design"} created by \code{mst_design()}.}

\item{num_panels}{Integer. Number of panels to be assembled.}

\item{global_min_use}{Scalar. Minimum number of times any item may be used
across panels. Default = \code{0}.}

\item{global_max_use}{Scalar. Maximum number of times any item may be used
across panels. Default = \code{Inf}.}

\item{item_min_use}{Optional data frame with columns \code{item_id} and
\code{min}, specifying item-specific minimum reuse counts. Default is \code{NULL}.}

\item{item_max_use}{Optional data frame with columns \code{item_id} and
\code{max}, specifying item-specific maximum reuse counts. Default is \code{NULL}.}
}
\value{
An object of S3 class \code{"mstATA_constraint"} with named elements:
\describe{
\item{name}{A character vector indicating the specifications in each row of \code{A_binary}}
\item{specification}{A \code{data.frame} summarizing the constraint specification, including
the requirement name, attribute, constraint type, application level,
operator, and the number of constraint rows generated.}
\item{A_binary}{A sparse binary matrix representing the linear constraint coefficients.}
\item{A_real}{NULL for 'mstATA_constraint' object}
\item{operators}{A character vector of constraint operators, one per row of \code{A_binary}.}
\item{d}{A numeric vector of right-hand-side values for the constraints.}
\item{C_binary}{NULL for 'mstATA_constraint' object}
\item{C_real}{NULL for 'mstATA_constraint' object}
\item{sense}{NULL for 'mstATA_constraint' object}
}
}
\description{
This function does \strong{not} need to be called by users and is internally used by \code{multipanel_spec()}.
It is a \strong{structural component} of multi-panel MST assembly.

It has two roles.
\itemize{
\item Define the semantics of the solution-level indicator
variable \eqn{s_i}: an item is considered \emph{used} if and only if it is selected
in at least one module of at least one panel.
\item Constrain user-specified \strong{minimum and maximum
reuse limits} for each item across all panels.
The total number of constraints depends on the number of items in the item pool
(for min and max usage, two constraints per item).
}
}
\details{
\strong{1. Specification}

The constraint enforces:

\strong{
Each item can be used at least a specified minimum number of times and/or
no more than a specified maximum number of times across all panels.
}

Key characteristics:

\itemize{
\item Attribute: \emph{itemset level (item-itself set)} \emph{logical} (if selected, then increment reuse).
\item Constraints are applied at the \strong{"Solution-level"}.
}

\strong{2. Number of times an item can be selected}

Global reuse limits are supplied via \code{global_min_use} and
\code{global_max_use}. These bounds apply to all items unless overridden.

Item-specific reuse limits may be supplied through:
\itemize{
\item \code{item_min_use}: a data frame with columns \code{item_id} and \code{min}
\item \code{item_max_use}: a data frame with columns \code{item_id} and \code{max}
}

The total number of constraints generated is always
\eqn{2 \times \text{PoolSize}}, corresponding to one minimum and one maximum
constraint per item.
}
\section{Mathematical Formulation}{


Suppose the item pool contains (S - 1) stimulus-based item sets, indexed by
\eqn{s = 1, \ldots, S - 1}. Each stimulus has a designated pivot item,
indexed by \eqn{i_s^{*}}. In addition, the pool contains a set of discrete
(nonâ€“stimulus-based) items, which are represented by a dummy stimulus
\eqn{s = S} to allow a unified indexing scheme. Items belonging to stimulus
\eqn{s} are indexed as \eqn{i_s = 1, 2, \ldots, I_s}.

Suppose there are \eqn{M} modules in an MST panel. Let
\eqn{m = 1, \ldots, M} denote the module index. Suppose
there are \eqn{P} panels assembled in one solution. Let
\eqn{p = 1, \ldots, P} denote the panel index.

\strong{Decision variable set 1: item-module-panel selection variables}

For each item \eqn{i_s},

\deqn{
  x_{i_s,m,p} =
  \begin{cases}
    1, & \text{if item } i_s \text{ is selected in module } m \text{ of panel } p, \\
    0, & \text{otherwise}.
  \end{cases}
}

\strong{Decision variable set 2: solution-level item indicators}

For each item \eqn{i_s},

\deqn{
  s_{i_s} =
  \begin{cases}
    1, & \text{if item } i_s \text{ is used in any module in any panel}, \\
    0, & \text{otherwise}.
  \end{cases}
}

\strong{Number of times item i is selected in a solution}

\deqn{
  u_i = \sum_{p}\sum_{m} x_{i_s,m,p}.
}

This constraints enforce:

\deqn{
  \text{min\_use}_i \, s_{i_s} \le u_i \le \text{max\_use}_i \, s_{i_s},
}

ensuring consistency between panel-level selections and solution-level
indicators while enforcing reuse limits.

where:
\itemize{
\item \eqn{x_{i_s,m,p}} indicates whether item \eqn{i_s} is selected in module
\eqn{m} of panel \eqn{p};
\item \eqn{s_{i_s}} indicates whether item \eqn{i_s} is used anywhere in the solution;
\item \eqn{\text{min\_use}_i} and \eqn{\text{max\_use}_i} are item-specific
reuse bounds.
}

These constraints are \strong{structural}: they define the meaning of the
solution-level indicator variables and also create constraints for the
item exposure control across panels.

\itemize{
\item If \eqn{s_i = 0}, then item \eqn{i} cannot be selected in any module
of any panel.
\item If \eqn{s_i = 1}, the total number of selections of item \eqn{i}
must lie within the specified reuse bounds.
\item If item \eqn{i} is not selected in any module across panels,
then \eqn{s_i} must equal 0.
\item If item \eqn{i} is selected in at least one module of any panel,
then \eqn{s_i} must equal 1.
}
}

\examples{
data("mini_itempool")

test_mstATA <- mst_design(
  itempool      = mini_itempool,
  design        = "1-3-3",
  module_length = c(6, 4, 4, 4, 3, 3, 3)
)

# Example: Allow each item to be used at most once across all panels
dvlink_item_solution(
  x = test_mstATA,
  num_panels = 2,
  global_max_use = 1
)


}
