% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_enemy_sets.R
\name{create_enemy_sets}
\alias{create_enemy_sets}
\title{Create Enemy Pairs and Enemy Sets}
\usage{
create_enemy_sets(id_col, enemy_col, sep_pattern = ",")
}
\arguments{
\item{id_col}{A character vector of item or stimulus identifiers
(e.g., item IDs or stimulus names).}

\item{enemy_col}{A character vector specifying enemy items or stimuli
associated with each element of \code{id_col}. The length must equal
\code{length(id_col)}. Missing values indicate no enemies.}

\item{sep_pattern}{A regular expression used to split multiple enemy
identifiers within \code{enemy_col}. Defaults to \code{","}.}
}
\value{
A list with the following components:
\describe{
\item{ExclusionPair}{A two-column character matrix in which each row
represents a unique pair of mutually exclusive (enemy) items or stimuli.}
\item{EnemySet}{A list of character vectors, where each element represents
a set of items or stimuli that are mutually exclusive with one another.}
}
}
\description{
Create pairwise enemy relationships and corresponding enemy sets for items
or stimuli based on metadata in the item pool.

This function parses enemy information from two aligned vectors—
an identifier column and an enemy-specification column—and returns
(1) a matrix of unique enemy pairs and (2) a list of enemy sets.
Enemy pairs represent item or stimulus combinations that must not be
selected together. See Details.

The function is intended as a \strong{preprocessing step} prior to constructing
enemy-item or enemy-stimulus exclusion constraints.
}
\details{
\strong{1. Enemy definition}

Two items or two stimuli are considered \emph{enemies} if they must not appear
together. Typical reasons include:

\itemize{
\item High surface similarity or paraphrasing
\item Shared clues or solution pathways
\item Security, exposure, or operational constraints
}

The \code{ExclusionPair} component is the \emph{authoritative definition}
of explicitly declared enemy relationships. Each row represents a single,
directly specified pairwise exclusion.

The \code{EnemySet} component provides a grouped representation of enemy
relationships for constraint construction. Enemy sets may include items
or stimuli that are connected through one or more pairwise exclusions in
\code{ExclusionPair}. Formally, each enemy set corresponds to a connected
component of the graph induced by \code{ExclusionPair}.

\strong{2. Interpretation of enemy relationships}

Enemy relationships specified through \code{enemy_col} are interpreted
\emph{transitively}. That is, if item/stimulus A is an enemy of B, and
B is an enemy of C, then A, B, and C are merged into a single
\emph{enemy set}. From each enemy set, at most one item or stimulus
may be selected.

This conservative interpretation prevents indirect information leakage
or similarity chains that may not be obvious from pairwise specifications
alone.

\strong{3. Important modeling note}

If users intend different \emph{types} of enemy relationships that should
\emph{not} propagate transitively, they should encode them in
\emph{separate columns} of the item pool.

For example:
\itemize{
\item Item A is an enemy of item B because they are \emph{too similar}.
\item Item B is an enemy of item C because they \emph{provide clues to each other}.
\item The user does \emph{not} believe that item A and item C should be treated
as enemies.
}

In this case, a safer modeling strategy is:
\itemize{
\item Encode the A–B enemy relationship in one enemy column
(e.g., \code{enemy_similarity});
\item Encode the B–C enemy relationship in a different enemy column
(e.g., \code{enemy_clueing});
\item Construct enemy sets separately from each column.
}

This approach prevents unintended transitive grouping, allowing items A and C
to remain eligible for joint selection while still enforcing the intended
pairwise exclusions.

In this case, users construct enemy sets separately, concatenate them using concat_enemy_sets(),
and supply the concatenated result to mst_design().
}
\examples{
## Example 1: Enemy item relationships
create_enemy_sets(
  id_col = mini_itempool$item_id,
  enemy_col = mini_itempool$enemy_similarity,
  sep_pattern = ","
)

## Example 2: Enemy stimulus relationships
create_enemy_sets(
  id_col = reading_itempool$stimulus,
  enemy_col = reading_itempool$enemy_stimulus,
  sep_pattern = ", "
)
}
\seealso{
\code{\link[=concat_enemy_sets]{concat_enemy_sets()}}
}
