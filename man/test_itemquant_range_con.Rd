% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test_itemquant_range_con.R
\name{test_itemquant_range_con}
\alias{test_itemquant_range_con}
\title{Generate Module/Pathway-Level Range Constraints for the Sum of Item Quantitative Attributes}
\usage{
test_itemquant_range_con(
  x,
  attribute,
  min = NULL,
  max = NULL,
  target = NULL,
  deviation = NULL,
  which_module = NULL,
  which_pathway = NULL
)
}
\arguments{
\item{x}{An object of class \code{"mstATA_design"} created by \code{mst_design()}.}

\item{attribute}{A string giving the column name in \code{x$ItemPool} containing the
quantitative attribute (e.g., time, difficulty, word count).}

\item{min}{Optional numeric scalar or vector of lower bounds.}

\item{max}{Optional numeric scalar or vector of upper bounds.}

\item{target}{Optional numeric scalar or vector of target values.}

\item{deviation}{Optional numeric scalar or vector of allowed deviations from the target.}

\item{which_module}{Optional integer vector of module indices to which the constraints
apply.}

\item{which_pathway}{Optional integer vector of pathway indices to which the
constraints apply.}
}
\value{
A combined constraint object of class \code{"mstATA_constraint"}, consisting of one or more quantitative constraints.
\describe{
\item{name}{A string indicating the specification name.}
\item{specification}{A \code{data.frame} summarizing the constraint specification, including
the requirement name, attribute, constraint type, application level,
operator, and the number of constraint rows generated.}
\item{A_binary}{A sparse binary matrix representing the linear constraint coefficients.}
\item{A_real}{NULL for 'mstATA_constraint' object}
\item{operators}{A character vector of constraint operators, one per row of \code{A_binary}.}
\item{d}{A numeric vector of right-hand-side values for the constraints.}
\item{C_binary}{NULL for 'mstATA_constraint' object}
\item{C_real}{NULL for 'mstATA_constraint' object}
\item{sense}{NULL for 'mstATA_constraint' object}
}
}
\description{
This function generates linear constraints on the \strong{sum of item-level quantitative
attributes} (e.g., total time, word count, difficulty) within specified module or pathway
of a multistage test (MST).

It supports two specification formats:

\itemize{
\item \strong{Direct range constraints:} using \code{min} and/or \code{max}
\item \strong{Target ± deviation constraints:} using \code{target} and \code{deviation}
}

Constraints may apply at the:
\itemize{
\item \strong{"Module-level"} — each module is treated as a separate test form, or
\item \strong{"Pathway-level"} — each pathway is treated as a complete test form.
}

The total number of constraints depends on the application level:

\itemize{
\item \strong{Module-level:} when \code{which_module} is provided,
or both \code{which_module} and \code{which_pathway} are \code{NULL}

\if{html}{\out{<div class="sourceCode">}}\preformatted{    Number of constraints = \\strong\{(# modules) × side\}
}\if{html}{\out{</div>}}

\item \strong{Pathway-level:} when \code{which_pathway} is provided and \code{which_module = NULL}

\if{html}{\out{<div class="sourceCode">}}\preformatted{    Number of constraints = \\strong\{ (# pathways) × side\}
}\if{html}{\out{</div>}}

}

Here, \code{side = 2} for range constraints (lower + upper bound) and
\code{side = 1} when only one bound is active.
}
\details{
\strong{1. Constraint Specification}

This function enforces:

\strong{The total sum of item quantitative attributes must lie within specified ranges
for specified module or pathway.}

The key properties of this constraint are:

\itemize{
\item The attribute type is \emph{quantitative}.
\item The attribute is defined at the \emph{item level} in the item pool.
\item Constraints may be applied at the module or pathway level.
}

\strong{2. Range specification: min, max, target, deviation}

Each of the four range-specification arguments may be:
\code{NULL}, scalar or vector

Interpretation:

\itemize{
\item \code{min}: minimum \strong{sum} of item quantitative values
\item \code{max}: maximum \strong{sum} of item quantitative values
\item \code{target}: desired \strong{sum} of item quantitative values
\item \code{deviation}: allowable deviation
}

When only \code{target} and \code{deviation} are provided:

\deqn{
  \text{min} = \text{target} - \text{deviation}, \qquad
  \text{max} = \text{target} + \text{deviation}.
}
}
\section{Mathematical Formulation}{


Suppose the item pool contains (S - 1) stimulus-based item sets, indexed by
\eqn{s = 1, \ldots, S - 1}. Each stimulus has a designated pivot item,
indexed by \eqn{i_s^{*}}. In addition, the pool contains a set of discrete
(non–stimulus-based) items, which are represented by a dummy stimulus
\eqn{s = S} to allow a unified indexing scheme. Items belonging to stimulus
\eqn{s} are indexed as \eqn{i_s = 1, 2, \ldots, I_s}.

Suppose there are \eqn{M} modules in an MST panel. Let
\eqn{m = 1, \ldots, M} denote the module index.

Let \eqn{q_{i_s}} be the quantitative attribute value of item \eqn{i_s}.

\strong{1. Module-level constraint (for module m)}
\deqn{
  b_{q}^{m,\min}
  \;\le\;
   \sum_{s=1}^{S} \sum_{i_s=1}^{I_s} q_{i_s} x_{i_s,m}
  \;\le\;
  b_{q}^{m,\max}
}

\strong{2. Pathway-level constraint (for pathway r)}

\deqn{
  b_{q}^{r,\min}
  \;\le\;
   \sum_{m \in r} \sum_{s=1}^{S} \sum_{i_s=1}^{I_s} q_{i_s} x_{i_s,m}
  \;\le\;
  b_{q}^{r,\max}
}

Here:
\itemize{
\item \eqn{x_{i_s,m}} is the binary decision variable indicating whether
item \eqn{i_s} is selected into module m.

\item \eqn{m \in r} denote modules belonging to pathway r.

\item \eqn{b_q^{m,\min}} and \eqn{b_q^{m,\max}} specify the lower and upper bounds for
the sum of item quantitative attribute in module m

\item \eqn{b_q^{r,\min}} and \eqn{b_q^{r,\max}} specify the lower and upper bounds for
the sum of item quantitative attribute in pathway r
}
}

\examples{
data("mini_itempool")

## Example 1: Difficulty range per module
test_mstATA <- mst_design(
  itempool = mini_itempool,
  design = "1-3-3",
  module_length = c(4,3,3,3,4,4,4)
)
test_itemquant_range_con(
  x = test_mstATA,
  attribute = "difficulty",
  min = c(-0.2*4, -0.7*2, -0.2*2, 0.3*2, -1.2*2, -0.2*2, 0.8*2),
  max = c( 0.2*4, -0.3*2,  0.2*2, 0.7*2, -0.8*2,  0.2*2, 1.2*2),
  which_module = NULL
)


## Example 2: Difficulty range per pathway
test_mstATA <- mst_design(
  itempool = mini_itempool,
  design = "1-3-3",
  exclude_pathways = c("1-1-3", "1-3-1"),
  pathway_length = 8
)

test_itemquant_range_con(
  x = test_mstATA,
  attribute = "difficulty",
  target = c(-1.2,-0.7,-0.2,0,0.2,0.7,1.2) * 8,
  deviation = 0.1 * 8,
  which_pathway = 1:7
)

}
\seealso{
\code{\link{test_itemquant_con}}
}
