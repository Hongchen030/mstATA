% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/weighted_sum_obj.R
\name{weighted_sum_obj}
\alias{weighted_sum_obj}
\title{Minimize or Maximize a Weighted Sum of Multiple Objective Functions}
\usage{
weighted_sum_obj(x, multiple_terms, strategy_args = list())
}
\arguments{
\item{x}{An object of class \code{mstATA_design} created by \code{mst_design()}.}

\item{multiple_terms}{A list containing \strong{two or more} objective components.
Each element must be either:
\describe{
\item{An objective term}{created using \code{objective_term()}.}
\item{A compiled objective}{produced by a multi-objective formulation
such as \code{maximin_obj()}, \code{capped_maximin_obj()},
\code{minimax_obj()}, or \code{goal_programming_obj()}.}
}
Each element may represent either a relative or an absolute objective.
The weighted aggregation respects the optimization sense (maximize or
minimize) specified within each objective term or compiled objective.}

\item{strategy_args}{A named list of strategy-specific arguments used by the
\strong{weighted_sum} aggregation.

Supported fields:
\itemize{
\item \code{weights} — A positive numeric vector of length
\code{length(multiple_term)} specifying the relative importance
of each objective term. Defaults to a vector of ones.
}}
}
\value{
A list of class \code{"compiled_objective"}
\describe{
\item{name}{A character vector indicating the specifications in each row of \code{A_binary}}
\item{specification}{A \code{data.frame} including "Requirement","Attribute","Type","Application Level","Operator","Num of Constraints"}
\item{A_binary}{Sparse matrix of coefficients for binary decision variables.}
\item{A_real}{Sparse matrix of coefficients for real decision variables.}
\item{operators}{A character vector of constraint operators, one per row of \code{A_binary}.}
\item{d}{A numeric vector of right-hand-side values for the constraints.}
\item{C_binary}{Penalty vector for binary variables (if any)}
\item{C_real}{Penalty vector for real variables (if any)}
\item{sense}{"min" or "max"}
\item{decisionvar_name_new}{Character vector indicating the names of new decision variables, same length as \code{ncol(A_real)}.}
\item{decisionvar_type_new}{A character vector of \code{"C"} (continuous), same length as \code{ncol(A_real)}.}
\item{notes}{List of metadata.}
}
}
\description{
This function compiles a \strong{weighted-sum objective} when multiple objective
terms are present. Each objective term contributes a linear score, and the
solver optimizes a weighted linear combination of these scores.

Under this strategy, multiple linear objective terms are aggregated into
a single objective function by forming a weighted linear combination.
}
\details{
\strong{1. Overview}

There are at least two objective term.

Each objective term represents a linear score of the form
\eqn{a^\top x}, constructed by \code{objective_term()}.

Key characteristics for each objective term:

(1) Categorical or Quantitative

\itemize{
\item \strong{maximize or minimize the number of items belonging to a specific
categorical level}, or
\item \strong{maximize or minimize the sum of quantitative item-level attribute
values}, such as difficulty, discrimination, or item information
function values.
}

(2) Module-, Pathway- or Panel-level

\itemize{
\item \strong{"Module-level"} — only items in a specified module contribute
to the objective;
\item \strong{"Pathway-level"} — items in all modules belonging to one
pathway contribute; and
\item \strong{"Panel-level"} — all item selections in the panel contribute.
}

(3) Relative or Absolute Objective

\itemize{
\item \strong{Relative objective}: maximize/minimize \eqn{a^\top x}.

\item \strong{Absolute deviation objective}: minimize the deviation from
a specified target: \eqn{ |a^\top x - \text{goal}|}
}

To combine these objectives, the function introduces an auxiliary continuous
variable \eqn{y_k} for each term and optimizes a weighted sum:

\deqn{
  \min \; \sum_{k=1}^K w_k \, y_k
  \quad \text{or} \quad
  \max \; \sum_{k=1}^K w_k \, y_k,
}

where \eqn{w_k > 0} are user-specified or default weights.

\strong{2. Handling Mixed Optimization Directions}

Objective terms may have different optimization directions:

\itemize{
\item some terms are to be minimized, and
\item others are to be maximized.
}

To maintain a single optimization sense, the compiled objective always uses
a \strong{minimization} form internally when mixed directions are present.

For any term that is originally a maximization objective, its score is
multiplied by -1. For example, if:

\itemize{
\item \eqn{y_1} and \eqn{y_2} are to be minimized, and
\item \eqn{y_3} is to be maximized,
}

then the combined objective becomes:

\deqn{
  \min \; \left( w_1 y_1 + w_2 y_2 - w_3 y_3 \right).
}

This transformation preserves the intended optimization direction for each
objective term while yielding a single linear objective function.

\strong{3.Practical Considerations for Choosing Weights}

As discussed in van der Linden (2005, pp. 68–69), selecting weights in a
multiobjective test-assembly problem can be challenging, particularly when
the objective terms are measured on different scales (e.g., test information,
content counts, exposure-related quantities).

Two key issues arise:
\itemize{
\item When objectives are on different scales, weights are difficult to
interpret and compare meaningfully.

\item When several weights are chosen to be close in magnitude, the optimal
solution may become unstable or unpredictable due to strong trade-offs
between competing attributes.
}

A partial remedy suggested by van der Linden is to first solve the assembly
problem separately for each objective term. These single-objective runs yield
benchmark values corresponding to solutions in which the entire weight is
placed on one objective and zero weight on all others.

The final weights in a weighted-sum formulation can then be selected by
compromising between these benchmark values, providing a more informed and
transparent basis for multiobjective trade-offs.

This strategy is especially useful during test design and exploratory phases,
where understanding the attainable extremes of each objective helps guide
principled weight selection.

\strong{How to use:}
\itemize{
\item Define individual objective terms using \code{objective_term()}.
Objective terms may be entirely relative, entirely absolute,
or a mixture of both.
\item Combine them directly using \code{weighted_sum_obj()}.
\item Alternatively, first construct compiled objectives using
\code{maximin_obj()}, \code{capped_maximin_obj()},
\code{minimax_obj()}, or \code{goal_programming_obj()},
and then combine multiple compiled objectives using
\code{weighted_sum_obj()}.
}
}
\section{Mathematical Formulation}{


For each objective term \eqn{k = 1, \ldots, K}:

\deqn{
  y_k = a_k^\top x,
}

where:

For relative objectives:
\itemize{
\item \eqn{a_k} is the coefficient vector defined by the attribute,
level, and application scope of the objective term;
\item \eqn{x} is the vector of binary item–module–panel decision variables;
\item the objective value is \eqn{y_k = a_k^\top x}.
}

For absolute (goal-based) objectives:
\itemize{
\item \eqn{a_k} is the coefficient vector defined by the attribute,
level, and application scope of the objective term;
\item \eqn{g_k} is the target value specified by the test developer;
\item the objective minimizes deviation from the target:
\eqn{|a_k^\top x - g_k|};
\item auxiliary deviation variables are introduced to linearize
the absolute value.
}

The weighted-sum objective is then:

\deqn{
  \min \; \sum_{k=1}^K w_k \, \tilde{y}_k,
}

where:

\deqn{
  \tilde{y}_k =
  \begin{cases}
    y_k,  & \text{if term } k \text{ is a minimization objective}, \\
   -y_k,  & \text{if term } k \text{ is a maximization objective}.
  \end{cases}
}
}

\examples{
data("mini_itempool")
test_mstATA <- mst_design(
  itempool        = mini_itempool,
  design          = "1-3-3",
  exclude_pathway = c("1-1-3", "1-3-1"),
  pathway_length  = 8
)

# Example: maximize test information at theta = -1, 0, and 1
# in the routing module, with targets at -1 and 1

obj1 <- objective_term(
  x             = test_mstATA,
  attribute     = "iif(theta=-1)",
  applied_level = "Module-level",
  which_module  = 1,
  sense         = "min",
  goal          = 12
)

obj2 <- objective_term(
  x             = test_mstATA,
  attribute     = "iif(theta=0)",
  applied_level = "Module-level",
  which_module  = 1,
  sense         = "max"
)

obj3 <- objective_term(
  x             = test_mstATA,
  attribute     = "iif(theta=1)",
  applied_level = "Module-level",
  which_module  = 1,
  sense         = "min",
  goal          = 12
)


weighted_sum_obj(x = test_mstATA, multiple_terms = list(obj1,obj2,obj3))

}
\references{
van der Linden, W. J. (2005).Linear models for optimal test design (pp. 68--69).https://doi.org/10.1007/0-387-29054-0
}
