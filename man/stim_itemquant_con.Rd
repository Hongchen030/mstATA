% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stim_itemquant_con.R
\name{stim_itemquant_con}
\alias{stim_itemquant_con}
\title{Generate Itemset-Level Constraints for Minimum/Exact/Maximum Sum
of Item Quantitative Attribute Values}
\usage{
stim_itemquant_con(
  x,
  attribute,
  operator,
  target_value,
  which_module = NULL,
  which_pathway = NULL
)
}
\arguments{
\item{x}{An object of class \code{"mstATA_design"} created by \code{mst_design()}.}

\item{attribute}{A string giving the column name in \code{x$ItemPool} that
represents the \strong{item-level quantitative attribute}.}

\item{operator}{A character string of constraint operators, one of
\code{"<="}, \code{"="}, or \code{">="}.}

\item{target_value}{Target values in specific module/pathway (\code{which_module}, \code{which_pathway}).}

\item{which_module}{Integer vector of modules. Must be consistent with the choices made in
\code{test_stimcount_con()}, \code{test_stimcat_con()},
and \code{test_stimquant_con()}.}

\item{which_pathway}{Integer vector of pathways. Must be consistent with the choices made in
\code{test_stimcount_con()}, \code{test_stimcat_con()},
and \code{test_stimquant_con()}.}
}
\value{
An object of S3 class \code{"mstATA_constraint"} with named elements:
\describe{
\item{name}{A character vector indicating the specifications in each row of \code{A_binary}}
\item{specification}{A \code{data.frame} summarizing the constraint specification, including
the requirement name, attribute, constraint type, application level,
operator, and the number of constraint rows generated.}
\item{A_binary}{A sparse binary matrix representing the linear constraint coefficients.}
\item{A_real}{NULL for 'mstATA_constraint' object}
\item{operators}{A character vector of constraint operators, one per row of \code{A_binary}.}
\item{d}{A numeric vector of right-hand-side values for the constraints.}
\item{C_binary}{NULL for 'mstATA_constraint' object}
\item{C_real}{NULL for 'mstATA_constraint' object}
\item{sense}{NULL for 'mstATA_constraint' object}
}
}
\description{
Creates a conditional quantitative constraint requiring that, if a stimulus
is selected, the \emph{sum of quantitative attribute values} of the
items linked to that stimulus must satisfy a user-specified lower bound,
upper bound, or exact value.

This function enforces a logical “if–then” relationship between stimulus
selection and the quantitative properties (difficulty, response time) of its associated items.

The total number of generated linear constraints = (number of stimuli) × (number of invovled modules)

For a range constraint (i.e., both a minimum and a maximum quantitative
requirement), the function must be called twice:
\itemize{
\item once with \code{target_value = min} and \code{operator = ">="}, and
\item once with \code{target_value = max} and \code{operator = "<="}.
}
}
\details{
\strong{1. Specification}

The constraint enforced is:

\strong{
If a stimulus is selected, then the items linked to it must
collectively satisfy a minimum, maximum, or exact sum of a quantitative
item attribute.
}

The key properties of this constraint are:

\itemize{

\item The attribute type is \emph{logical}: a conditional
"if–then" relationship between the selection of a stimulus and the required
selection of its associated items.

\item The attribute is defined at the \emph{itemset level: set size for each stimulus} in the item pool
through the mapping between a stimulus and the items that belong to it.

\item \emph{Conditional} stimulus–item constraints (such as
\code{stim_itemcount_con()}, \code{stim_itemcat_con()},
\code{stim_itemquant_con()}) must be applied at the \code{"Module-level"} because
\strong{items linked to a selected stimulus cannot be distributed across multiple modules}: if the stimulus is
selected in a module, all items required from that stimulus must appear in
the same module.

\item \strong{Important:} The arguments \code{which_module} and
\code{which_pathway} must be consistent with the choices made in
\code{test_stimcount_con()}, \code{test_stimcat_con()},
and \code{test_stimquant_con()}.
}

\strong{2. Why gating is required}

Because \eqn{q_{i_s}} may be negative or zero, the constraint alone does
\emph{not} guarantee that no items are selected when the stimulus is unselected
(\eqn{x_{i_s^{*},m} = 0}). Terms with negative coefficients can offset positive
terms, making the inequality feasible even when items are improperly selected.

Therefore, quantitative stimulus–item constraints must be paired with
either \code{stim_itemcount_con()} or \code{stim_itemcat_con()} constraint to guarantee logical consistency.

\deqn{x_{i_s^{*},m} = 0 \;\Rightarrow\; x_{i_s,m} = 0,}
}
\section{Mathematical Formulation}{


Suppose the item pool contains (S - 1) stimulus-based item sets, indexed by
\eqn{s = 1, \ldots, S - 1}. Each stimulus has a designated pivot item,
indexed by \eqn{i_s^{*}}. In addition, the pool contains a set of discrete
(non–stimulus-based) items, which are represented by a dummy stimulus
\eqn{s = S} to allow a unified indexing scheme. Items belonging to stimulus
\eqn{s} are indexed as \eqn{i_s = 1, 2, \ldots, I_s}.

Suppose there are \eqn{M} modules in an MST panel. Let
\eqn{m = 1, \ldots, M} denote the module index.

Let \eqn{q_{i_s}} be the quantitative attribute value of item \eqn{i_s}. Then for
module m, the conditional constraint is:

\deqn{
\sum_{i_s=1}^{I_s} q_{i_s} x_{i_s,m}
\;\; \substack{\le \\ \ge \\ =} \;\;
b_{q}^{m} \; x_{i_s^{*},m},
\qquad s = 1, \ldots, S - 1.
}

Here:

\itemize{
\item \eqn{x_{i_s,m}} is the binary decision variable indicating whether
item \eqn{i_s} is selected into module m.

\item \eqn{x_{i_s^{*},m}} indicates whether the pivot item for stimulus
s is selected into module m, thereby indicating whether the
stimulus s is selected in that module.

\item \eqn{b_{q}^{m}} is the required quantitative bound for the sum of
item-level quantitative attribute linked to every stimulus
in module m (minimum, maximum, or exact value).
}
}

\examples{
data("reading_itempool")
pivot_stim_map<-create_pivot_stimulus_map(itempool = reading_itempool,
                                          stimulus = "stimulus",
                                          pivot_item = "pivot_item")
# Example 1: if a stimulus is chosen, the sum difficulty of its linked items
# may be required to be smaller than 0.5.
test_mstATA<-mst_design(itempool = reading_itempool,design = "1-3-3",
                         module_length = c(14,12,12,12,12,12,12),
                        pivot_stim_map = pivot_stim_map)
stim_itemquant_con(x = test_mstATA,attribute = "difficulty",
                   operator = "<=",target_value = 0.5,
                  which_module = NULL,which_pathway = NULL)

}
\seealso{
\code{\link[=stim_itemcat_con]{stim_itemcat_con()}},\code{\link[=stim_itemcount_con]{stim_itemcount_con()}}
}
