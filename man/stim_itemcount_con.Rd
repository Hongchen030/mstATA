% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stim_itemcount_con.R
\name{stim_itemcount_con}
\alias{stim_itemcount_con}
\title{Generate Itemset-Level Constraints for the Number of Selected Items}
\usage{
stim_itemcount_con(
  x,
  min = NULL,
  max = NULL,
  which_module = NULL,
  which_pathway = NULL
)
}
\arguments{
\item{x}{An object of class \code{"mstATA_design"} created by \code{mst_design()}.}

\item{min}{An optional scalar specifying the minimum number of items to be
included conditional on the selection of its stimulus.}

\item{max}{An optional scalar specifying the maximum number of items to be
included conditional on the selection of its stimulus.}

\item{which_module}{Integer vector of modules. Must be consistent with the choices made in
\code{test_stimcount_con()}, \code{test_stimcat_con()},
and \code{test_stimquant_con()}.}

\item{which_pathway}{Integer vector of pathways. Must be consistent with the choices made in
\code{test_stimcount_con()}, \code{test_stimcat_con()},
and \code{test_stimquant_con()}.}
}
\value{
An object of S3 class \code{"mstATA_constraint"} with named elements:
\describe{
\item{name}{A character vector indicating the specifications in each row of \code{A_binary}}
\item{specification}{A \code{data.frame} summarizing the constraint specification, including
the requirement name, attribute, constraint type, application level,
operator, and the number of constraint rows generated.}
\item{A_binary}{A sparse binary matrix representing the linear constraint coefficients.}
\item{A_real}{NULL for 'mstATA_constraint' object}
\item{operators}{A character vector of constraint operators, one per row of \code{A_binary}.}
\item{d}{A numeric vector of right-hand-side values for the constraints.}
\item{C_binary}{NULL for 'mstATA_constraint' object}
\item{C_real}{NULL for 'mstATA_constraint' object}
\item{sense}{NULL for 'mstATA_constraint' object}
}
}
\description{
This function constructs linear constraints that enforce minimum, exact, or
maximum counts on the number of items associated with a selected stimulus.
It supports both full selection (all items linked to a stimulus must be
selected if the stimulus is selected) and partial selection (only a subset
of linked items must be selected).

The total number of generated linear constraints depends on the provided values of
\code{min} and \code{max}.

\itemize{

\item \strong{Full selection (min = NULL and max = NULL):}
All items linked to a stimulus must either all be selected or all not be
selected.

The number of constraints is
\strong{(number of stimuli) × (number of invovled modules)}.

\item \strong{Only max is specified:}
An upper bound is imposed, but no lower bound.

The number of constraints is
\strong{(number of stimuli) × (number of invovled modules)}.

\item \strong{Only min is specified:}
A lower bound is imposed; the upper bound defaults to the total number of
items belonging to each stimulus.

The number of constraints is
\strong{2 × (number of stimuli) × (number of invovled modules)}.

\item \strong{Both min and max are specified:}

If min is not equal to max (lower and upper bound are both active), the number of constraints is
\strong{2 × (number of stimuli) × (number of invovled modules)}.

If min = max (exact number), the number of constraints is
\strong{(number of stimuli) × (number of invovled modules)}.

}
}
\details{
\strong{1. Specification}

The constraint enforced is:

\strong{If a stimulus is selected, then a minimum, exact, or maximum number
of items linked to that stimulus must also be selected.}

The key properties of this constraint are:

\itemize{

\item The attribute type is \emph{logical}: a conditional
"if–then" relationship between the selection of a stimulus and the required
selection of its associated items.

\item The attribute is defined at the \emph{itemset level: set size for each stimulus} in the item pool
through the mapping between a stimulus and the items that belong to it.

\item \emph{Conditional} stimulus–item constraints (such as
\code{stim_itemcount_con()}, \code{stim_itemcat_con()},
\code{stim_itemquant_con()}) must be applied at the \code{"Module-level"} because
\strong{items linked to a selected stimulus cannot be distributed across multiple modules}: if the stimulus is
selected in a module, all items required from that stimulus must appear in
the same module.

\item \strong{Important:} The arguments \code{which_module} and
\code{which_pathway} must be consistent with the choices made in
\code{test_stimcount_con()}, \code{test_stimcat_con()},
and \code{test_stimquant_con()}.
}

\strong{2. Why gating is not required}

When only \code{min} is provided, the maximum bound \eqn{n^{\max}} is
automatically set to the total number of items belonging to stimulus s.
This produces a safe gating constraint: if the pivot item is not selected
(meaning the stimulus is not selected), then \eqn{x_{i_s^{*},m} = 0} forces
all item-selection variables \eqn{x_{m,i_s} = 0}, ensuring that no
items from an unselected stimulus can be inadvertently included.
}
\section{Mathematical Formulation}{


Suppose the item pool contains (S - 1) stimulus-based item sets, indexed by
\eqn{s = 1, \ldots, S - 1}. Each stimulus has a designated pivot item,
indexed by \eqn{i_s^{*}}. In addition, the pool contains a set of discrete
(non–stimulus-based) items, which are represented by a dummy stimulus
\eqn{s = S} to allow a unified indexing scheme. Items belonging to stimulus
\eqn{s} are indexed as \eqn{i_s = 1, 2, \ldots, I_s}.

Suppose there are \eqn{M} modules in an MST panel. Let
\eqn{m = 1, \ldots, M} denote the module index.

\deqn{
  n^{\min} \, x_{i_s^{*},m}
  \;\le\;
  \sum_{i_s = 1}^{I_s} x_{i_s,m}
  \;\le\;
  n^{\max} \, x_{i_s^{*},m},
  \qquad s = 1, \ldots, S - 1.
}

Here:
\itemize{
\item \eqn{x_{i_s,m}} is the binary decision variable indicating whether
item \eqn{i_s} is selected into module m.

\item \eqn{x_{i_s^{*},m}} indicates whether the pivot item for stimulus
s is selected into module m, thereby indicating whether the
stimulus is selected in that module.

\item \eqn{n^{\min}} and \eqn{n^{\max}} specify the minimum and maximum
allowable number of items that must be selected if its stimulus is selected.
}
}

\examples{
data("reading_itempool")
pivot_stim_map <- create_pivot_stimulus_map(
  itempool   = reading_itempool,
  stimulus   = "stimulus",
  pivot_item = "pivot_item"
)

test_mstATA <- mst_design(
  itempool      = reading_itempool,
  design        = "1-3-3",
  module_length = c(14, 12, 12, 12, 12, 12, 12),
  pivot_stim_map = pivot_stim_map
)

# Example 1: Full selection.
# If a stimulus is selected, all items linked to that stimulus must also be selected.
# 7 modules × 10 stimuli = 70 constraints
stim_itemcount_con(x = test_mstATA)

# Example 2: Range selection (min and max).
# If a stimulus is selected, between 2 and 5 of its linked items must be selected.
# Lower and upper bounds active → 2 × (7 modules × 10 stimuli) = 140 constraints
stim_itemcount_con(
  x = test_mstATA,
  min = 2,
  max = 5
)

# Example 3: Minimum-only selection.
# If a stimulus is selected, at least 5 of its items must be selected.
# Upper bound defaults to total items per stimulus → 2 × (7 × 10) = 140 constraints
stim_itemcount_con(
  x = test_mstATA,
  min = 5
)

# Example 4: Maximum-only selection.
# If a stimulus is selected, at most 8 of its items may be selected.
# Only upper bound active → 7 modules × 10 stimuli = 70 constraints
stim_itemcount_con(
  x = test_mstATA,
  max = 8
)

# Example 5: Exact selection.
# If a stimulus is selected, exactly 6 of its items must be selected (min = max = 6).
# Behaves like a single equality bound → 7 × 10 = 70 constraints
stim_itemcount_con(
  x = test_mstATA,
  min = 6,
  max = 6
)
}
\seealso{
\code{\link[=stim_itemcat_con]{stim_itemcat_con()}},\code{\link[=stim_itemquant_con]{stim_itemquant_con()}}
}
