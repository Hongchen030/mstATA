% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test_rdp_con.R
\name{test_rdp_con}
\alias{test_rdp_con}
\title{Routing Decision Point Information Balance Constraint}
\usage{
test_rdp_con(x, rdp, which_stage, info_tol = 0.5)
}
\arguments{
\item{x}{An object of class \code{"mstATA_design"} created by \code{mst_design()}.}

\item{rdp}{A numeric vector of routing decision points (theta values).
The length of \code{rdp} must equal the number of modules in
stage \code{which_stage + 1} minus one. Each element defines the routing
point between two adjacent modules in the next stage.}

\item{which_stage}{A single integer indicating the stage \emph{after which}
routing occurs. Routing constraints are applied to modules at
stage \code{which_stage + 1}. Routing cannot be defined after the final stage.}

\item{info_tol}{A single positive numeric value specifying the maximum
allowable difference in information between adjacent modules at each
routing decision point.}
}
\value{
An object of S3 class \code{"mstATA_constraint"} with named elements:
\describe{
\item{name}{A character vector indicating the specifications in each row of \code{A_binary}}
\item{specification}{A \code{data.frame} summarizing the constraint specification, including
the requirement name, attribute, constraint type, application level,
operator, and the number of constraint rows generated.}
\item{A_binary}{A sparse binary matrix representing the linear constraint coefficients.}
\item{A_real}{NULL for 'mstATA_constraint' object}
\item{operators}{A character vector of constraint operators, one per row of \code{A_binary}.}
\item{d}{A numeric vector of right-hand-side values for the constraints.}
\item{C_binary}{NULL for 'mstATA_constraint' object}
\item{C_real}{NULL for 'mstATA_constraint' object}
\item{sense}{NULL for 'mstATA_constraint' object}
}
}
\description{
Enforces similarity of test information at routing decision points (RDPs)
between adjacent modules in the \emph{next stage} of a multistage test (MST).
Routing is assumed to occur \strong{after examinees complete \code{which_stage}},
and constraints are imposed on modules at stage \code{which_stage + 1}.
}
\details{
For each routing decision point \eqn{\theta_{rdp}}, this function constrains
the difference in test information functions (TIFs) between adjacent
next-stage modules to be within a specified tolerance:
\deqn{
  | I_{m_j}(\theta_r) - I_{m_{j+1}}(\theta_r) | \le \text{info\_tol}
}

Adjacency is defined \strong{by ordering of modules within the same stage}.
This ensures correct behavior even when some
pathways are excluded from the design.

The constraint enforces:

\bold{The test information at the routing decision point between adjacent
modules in the next stage is similar within a specified tolerance.}

Key characteristics:

\itemize{
\item The attribute type is \emph{quantitative}.
\item The attribute is defined at the \emph{item level} in the item pool.
\item The constraints are applied at the \bold{"Module-level"}.
}

This function requires that item-level information functions
\code{iif(theta = theta_point)} already exist in the item pool.
These attributes can be prepared in advance using
\code{\link{compute_iif}}.

The constraint is implemented as a pair of linear inequalities for
each routing decision point, resulting in two constraint rows per
routing decision point.
}
\section{Mathematical Formulation}{


Suppose the item pool contains (S - 1) stimulus-based item sets, indexed by
\eqn{s = 1, \ldots, S - 1}. Each stimulus has a designated pivot item,
indexed by \eqn{i_s^{*}}. In addition, the pool contains a set of discrete
(nonâ€“stimulus-based) items, which are represented by a dummy stimulus
\eqn{s = S} to allow a unified indexing scheme. Items belonging to stimulus
\eqn{s} are indexed as \eqn{i_s = 1, 2, \ldots, I_s}.

Suppose there are \eqn{M} modules in an MST panel. Let
\eqn{m = 1, \ldots, M} denote the module index. Let
\eqn{x_{i_s m}} be a binary decision variable indicating whether item
\eqn{i_s} from stimulus \eqn{s} is selected into module \eqn{m}.

Let \eqn{\theta_{rdp}} denote a routing decision point (RDP) at which examinees
are routed to different modules in the next stage of the test. The item
information function of item \eqn{i_s} at ability level \eqn{\theta_r} is
denoted by \eqn{I_{i_s}(\theta_{rdp})}, and the corresponding module-level test
information function is given by
\deqn{
  I_m(\theta_{rdp}) = \sum_{s=1}^{S} \sum_{i_s=1}^{I_s}
  I_{i_s}(\theta_{rdp}) \, x_{i_s m}.
}

Consider routing after stage \eqn{k}. Let \eqn{\mathcal{M}_{k+1}} denote the
ordered set of modules at stage \eqn{k+1}. For each pair of adjacent modules
\eqn{(m_j, m_{j+1})} in \eqn{\mathcal{M}_{k+1}}, a routing decision point
\eqn{\theta_{r_j}} is specified. The routing information balance constraint
requires that the difference in test information between adjacent modules at
the routing decision point be bounded by a user-specified tolerance
\eqn{\delta > 0}:
\deqn{
  \left| I_{m_j}(\theta_{r_j}) - I_{m_{j+1}}(\theta_{r_j}) \right|
  \le \delta.
}

Each absolute-value constraint is implemented as a pair of linear
inequalities, resulting in two constraint rows per routing decision point.
}

\examples{
data("mini_itempool")
mini_itempool[,paste0("iif(theta=",c(-0.5,0.5),")")]<-compute_iif(mini_itempool,
item_par_cols = list("3PL"=c("discrimination","difficulty","guessing")),
                                                     theta = c(-0.5,0.5),model_col = "model")
test_mstATA <- mst_design(
  itempool = mini_itempool,module_length = c(3,4,4,4),
  design = "1-3"
)
test_rdp_con(x = test_mstATA,rdp = c(-0.5, 0.5),
             which_stage = 1,info_tol = 0.4)
}
\seealso{
\code{\link[=compute_iif]{compute_iif()}}
}
