% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/joint_module_score_dist.R
\name{joint_module_score_dist}
\alias{joint_module_score_dist}
\title{Compute one-step joint score distribution under routing}
\usage{
joint_module_score_dist(
  cdist_by_prev,
  prev_scores,
  icc_by_next_mod,
  possible_joint_score
)
}
\arguments{
\item{cdist_by_prev}{Numeric matrix.
Rows correspond to previous score values given in \code{prev_scores};
columns correspond to theta points.}

\item{prev_scores}{Integer vector of non-negative values giving the score
values associated with the rows of \code{cdist_by_prev}.}

\item{icc_by_next_mod}{Named list of ICC matrices for the next module.
Each element corresponds to a theta point and must be compatible with
\code{\link{module_score_dist}}.
Names must match the column names of \code{cdist_by_prev}.}

\item{possible_joint_score}{Integer vector of non-negative cumulative scores
that are reachable under this routing branch.}
}
\value{
A numeric matrix with:
\itemize{
\item rows corresponding exactly to \code{possible_joint_score},
\item columns corresponding to theta points.
}

Each column represents the (unnormalized) joint score distribution at that
theta.
}
\description{
Computes the joint (cumulative) score distribution after administering a
next-stage module, conditional on routing into a branch defined by a set of
reachable previous scores.

This function performs a \emph{single-step convolution} between:
\itemize{
\item the conditional score distribution from previous stages, and
\item the score distribution of the next module.
}

No recursion is performed.

The returned distribution is \strong{not normalized}: for each theta column,
the column sum equals the probability of routing into this branch at that
theta.
}
\details{
Let \eqn{S_{prev}} denote the cumulative score prior to the current stage,
and \eqn{S_{next}} the score from the next-stage module.
This function computes:

\deqn{
  P(S = s \mid \theta)
  = \sum_{k} P(S_{prev} = k \mid \theta)
    \, P(S_{next} = s - k \mid \theta)
}

for all s in \code{possible_joint_score}.
}
\examples{
## toy previous score distribution
prev_scores <- 0:2
cdist_by_prev <- matrix(
  c(0.2, 0.3,
    0.5, 0.4,
    0.3, 0.3),
  nrow = 3,
  dimnames = list(NULL, c("theta=-1", "theta=0"))
)

## simple ICC: two items, dichotomous
icc <- matrix(
  c(0.4, 0.6,
    0.7, 0.3),
  nrow = 2,
  byrow = TRUE
)
colnames(icc) <- c("0", "1")

icc_by_next_mod <- list(
  "theta=-1" = icc,
  "theta=0"  = icc
)

possible_joint_score <- c(1, 2, 3)

joint_module_score_dist(
  cdist_by_prev,
  prev_scores,
  icc_by_next_mod,
  possible_joint_score
)

}
