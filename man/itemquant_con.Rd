% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itemquant_con.R
\name{itemquant_con}
\alias{itemquant_con}
\title{Generate Item-Level Constraints Requiring Quantitative Attributes
to Satisfy Lower, Upper, or Range Bounds (Not for Operational Use)}
\usage{
itemquant_con(
  x,
  attribute,
  min = NULL,
  max = NULL,
  which_module = NULL,
  which_pathway = NULL
)
}
\arguments{
\item{x}{An object of class \code{"mstATA_design"} created by \code{mst_design()}.}

\item{attribute}{A string giving the column name in \code{x$ItemPool} that
represents the \strong{item-level quantitative attribute}.}

\item{min}{A numeric scalar for the lower bound.}

\item{max}{A numeric scalar for the upper bound.}

\item{which_module}{Optional integer vector of module indices to which the constraints
apply.}

\item{which_pathway}{Optional integer vector of pathway indices to which the
constraints apply.}
}
\value{
This function always throws an error indicating that it is
\strong{not for operational use}.

It is retained solely as an illustrative example of how item-level
quantitative constraints propagate through different hierarchical levels
of an MST design.
}
\description{
This function constructs linear constraints enforcing that every selected item
satisfies a quantitative attribute requirement (e.g., difficulty greater than c, item
length less than c, discrimination within a range).

Constraints may be applied at the \code{"Module-level"}, \code{"Pathway-level"}, or
\code{"Panel-level"}.

\strong{This function is for demonstration only and is \emph{not intended for operational use}.}
It generates an
excessively large number of rows in the constraint matrix and requires
item-level attributes to be strictly positive.

The number of generated linear constraints depends on the application level:

\itemize{
\item \strong{Module-level:} when \code{which_module} is provided

The number of constraints is
\strong{(number of items) × (number of modules specified) × side}

\item \strong{Pathway-level:} when \code{which_pathway} is provided and
\code{which_module = NULL}

The number of constraints is
\strong{(number of items) × (number of unique modules in specified pathways) × side}

\item \strong{Panel-level:} both \code{which_module} and \code{which_pathway} are \code{NULL}

The number of constraints is
\strong{(number of items) × (total number of modules) × side}
}

where \code{side = 1} for one-sided constraints (min-only or max-only)
and \code{side = 2} when both \code{min} and \code{max} are provided and
min is not equal to max.
}
\details{
\strong{1. Specification}

The constraint enforces:

\strong{Each selected item must satisfy the specified quantitative
lower bound, upper bound, or both.}

Key characteristics:
\itemize{
\item The attribute type is \emph{quantitative}.
\item The attribute is defined at the \emph{item level} in the item pool.
\item Application levels:
\itemize{
\item \strong{Module-level}: enforce items selected in specific module(s) satisfy the quantitative requirement.
\item \strong{Pathway-level}: enforce items selected in any module of a pathway satisfy the quantitative requirement.
\item \strong{Panel-level}: enforce items selected in the panel satisfy the quantitative requirement.
}
}

\strong{2. Important Restriction}

There are two reasons this approach is discouraged. First, item-level
quantitative constraints generate an excessively large number of
constraint rows, leading to poor computational efficiency. Second, the
formulation requires scaling item-selection variables by the attribute
value \eqn{q_{i_s}}. If \eqn{q_{i_s}} is zero or negative, the resulting
inequalities become invalid.

Because many commonly used item attributes (e.g., IRT difficulty parameters
or centered text indices) may take zero or negative values,
\strong{this function is not suitable for operational MST assembly}.

Instead, per-item quantitative rules should be enforced during the design
stage using \code{item_module_eligibility()} within \code{mst_design()},
which excludes ineligible items prior to module assembly.
}
\section{Mathematical Formulation}{


Suppose the item pool contains (S - 1) stimulus-based item sets, indexed by
\eqn{s = 1, \ldots, S - 1}. Each stimulus has a designated pivot item,
indexed by \eqn{i_s^{*}}. In addition, the pool contains a set of discrete
(non–stimulus-based) items, which are represented by a dummy stimulus
\eqn{s = S} to allow a unified indexing scheme. Items belonging to stimulus
\eqn{s} are indexed as \eqn{i_s = 1, 2, \ldots, I_s}.

Suppose there are \eqn{M} modules in an MST panel. Let
\eqn{m = 1, \ldots, M} denote the module index.

Let \eqn{q_{i_s}} be the quantitative attribute value of item \eqn{i_s}.

Upper-bound constraint:
\deqn{
  q_{i_s} \, x_{i_s, m} \le b_q^{item,max}
}

Lower-bound constraint:
\deqn{
  b_q^{item,min} \, x_{i_s, m} \le q_{i_s}
}

For two-sided range constraints, both inequalities are included.
(\code{min} and \code{max} both provided and not
equal), the number of constraints is doubled (\code{side = 2}).
For one-sided constraints, \code{side = 1}.

Here:
\itemize{
\item \eqn{x_{i_s, m}} is the binary decision variable indicating whether
item \eqn{i_s} is selected into module m.

\item \eqn{q_{i_s}} (\strong{must be positive values}) denote the values of a quantitative attribute for item \eqn{i_s}.

\item \eqn{b_q^{item,min}} and \eqn{b_q^{item,max}} are the lower and
upper allowable bounds for the attribute \eqn{q_{i_s}}.
}
}

\seealso{
\code{\link{mst_design}}
}
