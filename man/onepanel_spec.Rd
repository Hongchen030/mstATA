% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/onepanel_spec.R
\name{onepanel_spec}
\alias{onepanel_spec}
\title{Define a Single-Panel mstATA Model}
\usage{
onepanel_spec(x, constraints, objective = NULL)
}
\arguments{
\item{x}{An object of class \code{"mstATA_design"} created by \code{mst_design()}.}

\item{constraints}{A list of \code{"mstATA_constraint"} objects defining
requirements for assembling \strong{one panel}.
Constraints that explicitly reference multiple panels (i.e., solution-level
constraints across panels) are not allowed and will be rejected.}

\item{objective}{Optional compiled objective of class
\code{"compiled_objective"}.
Objectives may introduce auxiliary decision variables and additional
constraints, and are only permitted for operational (single-panel)
specifications.}
}
\value{
An object of class \code{"mstATA_model"}, represented as a named list
containing constraint matrices, objective coefficients, decision variable
metadata, bounds, and optimization sense.
\describe{
\item{name}{A character vector indicating the specifications in each row of \code{A_binary}}
\item{specification}{A \code{data.frame} summarizing the constraint specification, including
the requirement name, attribute, constraint type, application level,
operator, and the number of constraint rows generated.}
\item{A_binary}{A sparse constraint matrix (class \code{"Matrix"}) for binary
decision variables. Rows correspond to constraints; columns correspond to
binary decision variables.}
\item{A_real}{A sparse constraint matrix (class \code{"Matrix"}) for
continuous decision variables. Must have the same number of rows as
\code{A_binary}.}
\item{A}{Constraint coefficient matrix (sparse or dense).}
\item{C_binary}{A numeric vector of objective coefficients for binary decision
variables.}
\item{C_real}{A numeric vector of objective coefficients for continuous
decision variables.}
\item{obj}{Objective function coefficient vector.}
\item{d}{Right-hand-side vector of constraints.}
\item{operators}{Constraint operators (e.g., \code{"<="}, \code{">="}, \code{"="}).}
\item{vtype}{Decision variable types (\code{"B"} for binary, \code{"C"} for continuous).}
\item{varname}{Decision variable names.}
\item{lb}{Lower bounds for decision variables.}
\item{ub}{Upper bounds for decision variables.}
\item{sense}{Optimization sense (\code{"min"} or \code{"max"}).}
}
}
\description{
Constructs a \strong{single-panel ATA specification} by assembling constraints,
optional objective formulations, and required decision-variable
linking rules into a solver-ready model with full semantic traceability.

This function validates that all supplied constraints apply to a \emph{single}
panel, automatically injects decision-variable linking constraints when
required, and records row-index ranges that map semantic requirements to
solver constraint rows.
}
\details{
\strong{1. Constraint scope}

All constraints supplied to \code{onepanel_spec()} must apply to a
single panel. This includes attributes defined at the item, stimulus,
itemset, module, pathway, or panel level.

Constraints that operate \emph{across panels} (solution-level reuse or exposure
constraints) must be specified during multi-panel expansion and are not
permitted in a single-panel specification.

\strong{2. Automatic decision-variable linking}

If module-level logical constraints involving item–stimulus relationships
are detected (e.g., \code{stim_itemquant_con}), and neither
\code{stim_itemcount_con} nor \code{stim_itemcat_con} is included,
\code{onepanel_spec()} automatically injects item–stimulus gating constraints
via all-in/all-out selection.

This ensures that item-level and stimulus-level selections remain
logically consistent. In other words, when constraints reference
item–stimulus relationships without explicitly enforcing selection linkage,
the required decision-variable linking constraints are added implicitly.

\strong{3. Row-index traceability}

All constraint rows—including those introduced by objectives and
automatically injected decision-variable linking constraints—are assigned
contiguous row-index ranges in the compiled constraint matrix.

These ranges are recorded in the returned \code{specification} table,
allowing users to:

\itemize{
\item diagnose infeasibility,
\item identify binding constraint groups, and
\item programmatically relax or prioritize subsets of constraints.
}
}
\examples{
data("reading_itempool")

pivot_stim_map <- create_pivot_stimulus_map(
  itempool   = reading_itempool,
  stimulus   = "stimulus",
  pivot_item = "pivot_item"
)

test_mstATA <- mst_design(
  itempool = reading_itempool,
  design   = "1-3-3",
  module_length = c(14,12,12,12,12,12,12),
  pivot_stim_map = pivot_stim_map
)
spec1<-test_itemcount_con(x=test_mstATA)
spec2<-test_stimcat_con(
  x = test_mstATA,
  attribute = "stimulus_type",
  cat_levels = c("history","social studies"),
  operator = "=",
  target_num = c(1,1),
  which_module = 1)
spec3<-test_stimcat_con(
  x = test_mstATA,
  attribute = "stimulus_type",
  cat_levels = "history",
  operator = "=",
  target_num = 2,
  which_module = 2:4)
spec4<-test_stimcat_con(
  x = test_mstATA,
  attribute = "stimulus_type",
  cat_levels = "social studies",
  operator = "=",
  target_num = 2,
  which_module = 5:7)
spec5<-stim_itemcount_con(
  x = test_mstATA,
  min = 5,
  max = 7
)
obj_term<-objective_term(x = test_mstATA,attribute = "discrimination",
                         applied_level = "Module-level",which_module = 1,sense = "max")

panel_spec <- onepanel_spec(
  x = test_mstATA,
  constraints = list(spec1,spec2,spec3,spec4,spec5),
  objective = single_obj(x=test_mstATA,single_term = obj_term)
)


}
